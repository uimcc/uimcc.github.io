{"meta":{"title":"说IT","subtitle":"关注技术和人文的原创IT博客","description":"说IT是一个面向Apple和JavaScript生态的技术博客，内容聚焦于前后端开发、产品设计等方向。作者：唐先森(@tangkunyin)，网址：https://shuoit.net。","author":"唐先森(https://www.tangkunyin.com)","url":"https://shuoit.net"},"pages":[{"title":"移动互联网？","date":"2017-03-18T11:56:20.000Z","updated":"2018-08-29T12:27:52.373Z","comments":false,"path":"app/index.html","permalink":"https://shuoit.net/app/index.html","excerpt":"","text":"憋闹了，还没App。网页写的差不多了，再考虑写移动互联网….public static void main(String args[]) throws Exception &#123; for (int i = 0; ; i++) &#123; Thread.sleep(1000); System.out.println(\"嗯、写码，呵呵...\" + i); &#125;&#125; fyiguhjnwkefnmwoeih68yuih4jnkrfewdfyugbijnk.wfww3f 5jhyrtgve5jhytbgvef5grefvqwu6ejynhbvwer5jr5hb4gevgwh54uh3g4weab eh43eg223t4whretbvfw345u36jhtbevww32q4wu5ejhtbevwgw354uhtbgevfcewg 擦了下键盘，这些你可以拿去当QQ密码，绝不会被盗号，不用谢！","keywords":null},{"title":"为何建站 && 为何写作","date":"2017-02-07T05:23:07.000Z","updated":"2018-08-29T12:27:52.372Z","comments":false,"path":"about/index.html","permalink":"https://shuoit.net/about/index.html","excerpt":"","text":"为何建站在我年轻的时候，独立站长曾是一个牛逼闪闪的角色，然而现在不那么神秘了。搭建说IT这个网站主要是为了记录技术成长的点滴，当然装逼也是一个目的。 为何写写作 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。 引自《MacTalk》跨越边界 显然，写作是个艺术活儿，这个博客是带有某种程序员感情的，如果你是这种艺术家，那就能共震了！ 本站主要作为技术笔记存档，内容主要涉及前端开发（含移动端），偶尔可能也会有一些碎碎念、开开车。如果某一篇帮助了你，请记得点个赞。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。如有兴趣，欢迎一起码字。 关于作者斜杠中年、文字控、周杰伦迷，就职于粗粮厂的90后程序猿。目前致力于JavaScript大法，ReactNative是目前的工作。鸡汤一站，请自取一篇饮 如果您遇到麻烦或对本站有疑问，请在本站找到那个白色❓号并点击查看 没时间再解释了，赶紧上车…","keywords":"关于说IT，说IT是什么"},{"title":"QA - 帮助那个中心...","date":"2017-03-29T10:49:38.000Z","updated":"2018-08-29T12:27:52.374Z","comments":true,"path":"help/index.html","permalink":"https://shuoit.net/help/index.html","excerpt":"","text":"这里不发表情，准备说点严肃、实在的…Q: 这网站怎么弄的，还挺好看的啊？ A: 本站是静态博客，通过hexo生成，主题是我自己写的。免费使用，已开源至GitHub，本站底部有它们的链接 Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 Q: 我也想用这个主题搭个博客，不知道怎么弄？ A: 先去hexo官网看看，学会用这个写作并学会使用gitpages之类的部署博客。教程谷歌一下遍地皆是。主题是免费的，在本站底部可找到链接，根据文档自及配置就好了。遇到问题，在本页留言即可，我会很愿意帮助你的。需要注意的是主题有全站https开关，在主题_config.yml文件的fullHttps处配置。如配置不当r某些文件就无法正确引用，加载粗来的页面会很挫。 Q: 你这主题，我配置了怎么运行报错啊，跑不起来啊？ A: 关于使用主题出错，请先前往JSimple-issues寻找答案，说不定你遇到的问题，已经有人碰到而我也回答解决方式了。关于主题的任何问题，我都会在那里回复 Q: 无法自由翱翔互联网咋办？ A: 着急吃饭且自甘有钱的朋友请直接购买蓝灯。不着急就慢慢找吧，像GreenVPN、www.ishadowsocks.com都是很好的方案。另外有hosts方案，请前往这个项目UsefullShells Q: 如何找到一个靠谱的对象？ 如果你有资源，记得第一时间告诉我… Q: 我觉得站长你挺有意思的，能交个朋友吗？ A: 可以，来握个手吧：斜杠中年 暂时更新这些，需要什么本文底部留言……","keywords":"help，qa，帮助中心，站内帮助"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-08-29T12:27:52.466Z","comments":true,"path":"tags/index.html","permalink":"https://shuoit.net/tags/index.html","excerpt":"","text":""},{"title":"嘉宾推荐","date":"2017-02-07T05:22:22.000Z","updated":"2018-08-29T12:27:52.465Z","comments":false,"path":"links/index.html","permalink":"https://shuoit.net/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等","keywords":"嘉宾推荐，友情链接"},{"title":"时光轴","date":"2017-02-07T05:23:27.000Z","updated":"2018-08-29T12:27:52.467Z","comments":false,"path":"timeline/index.html","permalink":"https://shuoit.net/timeline/index.html","excerpt":"","text":"时光轴嘛，得先有时光，会更新的，别急……","keywords":null}],"posts":[{"title":"致为知笔记们","slug":"致为知笔记们","date":"2018-06-03T12:48:34.000Z","updated":"2018-08-29T12:27:52.370Z","comments":true,"path":"others/WizNote-Uninstall/1528030114.html","link":"","permalink":"https://shuoit.net/others/WizNote-Uninstall/1528030114.html","excerpt":"","text":"用了近三年，你们也不容易，哎…今天干了多半天的体力活，将为知笔记上的技术内容整理、删减各种折腾，最终留下并迁移了近40篇到HEXO。虽说不是什么精华，但那毕竟是记忆。 2015年4月21日我们相遇，对比了印象笔记等XX类笔记后，看上了你。今天还是不得不分手… 尤其是前阵子升级差点丢了数据，近乎懵逼的感觉让我下决心抛弃你。庆幸手没那么快。如果先卸载了，那只有哭了… 也怪我没及时看到你的更新公告： 关于升级至新同步服务的公告 嗯，往后，还是自己托管的好 加油吧…","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"Mac必备工具","slug":"MacTools","permalink":"https://shuoit.net/tags/MacTools/"}],"keywords":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}]},{"title":"Vue学习笔记","slug":"Vue学习笔记","date":"2018-06-03T12:12:54.000Z","updated":"2018-08-29T12:27:52.355Z","comments":true,"path":"front-end/vue-study-notes/1528027974.html","link":"","permalink":"https://shuoit.net/front-end/vue-study-notes/1528027974.html","excerpt":"","text":"一，建立一个Vue工程： 然后就完了…. 二，打开这个功能，命令行执行：npm run dev ，就可以看到正常的网页三，单文件组件的写法与用法： 新建一个vue文件，写好内容； 需要的地方引入，其中注意 @ 为 Vue自带的，表示src。如以下引用方式： 使用Less支持，package.json中添加：less和less-loader，然后文件夹：build-&gt;webpack-base-config.js中添加如下： &#123; test: /\\.less$/, loader: 'style-loader!css-loader!less-loader'&#125; 暂时玩儿到这里，有需要会继续折腾…代码： Hello-FE","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"Vue","slug":"Vue","permalink":"https://shuoit.net/tags/Vue/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"React16的一些问题及对策","slug":"React16的一些问题及对策","date":"2018-06-03T12:07:12.000Z","updated":"2018-08-29T12:27:52.352Z","comments":true,"path":"front-end/react16-usage/1528027632.html","link":"","permalink":"https://shuoit.net/front-end/react16-usage/1528027632.html","excerpt":"","text":"1，如果render中的组件以属性的方式引用了当前类的函数，且在constructor中bind这个函数，会造成这个函数仅刷新一次，如： 解决方式：在Render中bind，在SCU中再拦截，控制实际Render次数 原因是：暂时不知道！！！捂脸.png捂脸.png捂脸.png","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"ReactNative","slug":"RN","permalink":"https://shuoit.net/tags/RN/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"ReactNative导航的解决方案","slug":"ReactNative导航的解决方案","date":"2018-06-03T11:59:46.000Z","updated":"2018-08-29T12:27:52.352Z","comments":true,"path":"front-end/react-navigation/1528027186.html","link":"","permalink":"https://shuoit.net/front-end/react-navigation/1528027186.html","excerpt":"","text":"一、纯JS的解决方案：React Navigation易用、跨平台、良好的状态管理教程： https://www.jianshu.com/p/2f575cc35780https://www.jianshu.com/p/b877115fff1b 概况，React Navigation分为三个部分：StackNavigator：类似顶部导航条，用来跳转页面和传递参数；TabNavigator：类似底部标签，用来区分模块；DrawerNavigator：抽屉，类似从APP侧滑出一个页面 1、注意事项： iOS和Android平台的tabs默认行为不一致，表现在iOS正常，安卓的tab在顶部且处于可滑动状态，一统江山方法如下： const Navigation = TabNavigator( &#123; tab1: &#123; screen: screen1 &#125;, tab2: &#123; screen: screen2 &#125;, &#125;, // customize app tab bars &#123; tabBarPosition: 'bottom', tabBarComponent: TabBarBottom, // 安卓默认是顶部，不设置该项可能导致tabIcon位置错误 swipeEnabled: false, // 安卓默认可滑动 lazy: true, initialRouteName: 'Offline', tabBarOptions: &#123; indicatorStyle: &#123; height: 0, // android 中TabBar下面会显示一条线，高度设为 0 后就不显示线了 &#125;, style: &#123; height: 49, backgroundColor: 'white' &#125;, labelStyle: &#123; marginBottom: 3 &#125;, iconStyle: &#123; height: 24, width: 24, margin: 0 &#125;, showIcon: true, // 是否显示图标，安卓默认关闭 // label和icon的前景色 活跃状态下（选中） activeTintColor: '#4ECBFC', // label和icon的前景色 不活跃状态下(未选中) inactiveTintColor: '#aaa', // label和icon的背景色 活跃状态下 activeBackgroundColor: 'white', // label和icon的背景色 不活跃状态下 inactiveBackgroundColor: 'white', // 不透明度为按选项卡(iOS和Android &lt; 5.0) pressOpacity: 0.3, scrollEnabled: false， // 是否启用可滚动的选项卡，安卓特有 &#125; &#125;); 安卓tabbar文字会下移，因为安卓比iOS多一个属性，就是iconStyle，通过设置labelStyle和iconStyle两个样式，可以调整整理合理性。 2、安卓导航栏文字默认居左调整自定义导航样式，重写： headerTitleStyle 3、让安卓实现push动画// 先引入这个方法import CardStackStyleInterpolator from 'react-navigation/src/views/CardStackStyleInterpolator';​// 在StackNavigator配置headerMode的地方，使用transitionConfig添加&#123; headerMode: 'screen', transitionConfig:()=&gt;(&#123; screenInterpolator:CardStackStyleInterpolator.forHorizontal, &#125;)&#125; 二、iOS平台专用的：NavigatorIOS提供UINavigationViewController类的方法。其中Navigator已经被正式废弃！（于RN44被抛弃） 替代方案：react-native-deprecated-custom-components 三、Native外观和体验的跨端方案：native-navigation, react-native-navigation.其中前者有AirBnb团队开发，1.x前处于不稳定版本。不建议投入正式用途。后者由WiX团队提供。目前功能已经相对完整，功能完全。必须在RN 0.43以后才可以用。如果是混合开发，比如RN模块只作为一个TAB嵌入，那么可以考虑这种方案。 具体资料如下：https://wix.github.io/react-native-navigation/#/","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"ReactNative","slug":"RN","permalink":"https://shuoit.net/tags/RN/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"pm2控制多个ReactNative控制台","slug":"pm2控制多个ReactNative控制台","date":"2018-06-03T11:50:35.000Z","updated":"2018-08-29T12:27:52.362Z","comments":true,"path":"front-end/pm2-rn-combine/1528026635.html","link":"","permalink":"https://shuoit.net/front-end/pm2-rn-combine/1528026635.html","excerpt":"","text":"一、pm2小试牛刀1、安装PM2：pm2 npm install pm2 -g 2、常用命令： pm2 ls pm2 monit 3、 常用的服务启动命令：// 从某个文件作为服务入口启动pm2 start app.js​// 启动所有定义在packge.json中的服务pm2 start package.json​// 启动一个Node应用程序pm2 start npm -- start 二、ReactNative默认端口修改 默人情况下，ReactNative的PackageManager端口是8081。 1、临时修改端口（这个命令是2017年8月1号以后增加的功能） // 监听9999react-native start –port 9999 2、永久修改planA： 手动修改所有涉及端口的文件，具体文件可谷歌 planB： https://github.com/ktonon/react-native-port-patcherscript中加postinstall，devDependences加 \"postinstall\": \"react-native-port-patcher --new-port 9092\"\"react-native-port-patcher\": \"^1.0.2\" 安装以后，执行： yarn install | npm install打开Xcode后，重新编译，就可使用新的端口 三、pm2控制多个ReactNative服务启动一个名为xxName的进程，可多个一起 pm2 start npm –name xxName – run start​ 这种方式会启动一个名为npm的进程，如果不区别名称，则另外一个无法启动 pm2 start npm – start","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"ReactNative","slug":"RN","permalink":"https://shuoit.net/tags/RN/"},{"name":"pm2","slug":"pm2","permalink":"https://shuoit.net/tags/pm2/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"创建ReactNative项目的优雅方式","slug":"创建ReactNative项目的优雅方式","date":"2018-06-03T11:40:20.000Z","updated":"2018-08-29T12:27:52.363Z","comments":true,"path":"front-end/create-rn-in-better-way/1528026020.html","link":"","permalink":"https://shuoit.net/front-end/create-rn-in-better-way/1528026020.html","excerpt":"","text":"先说不优雅的方式，即：react-native init xxx可以在init时加上模板参数，即： react-native init xxx –template youui // 这个意思就是生成youui开发样板（脚手架） 这种方式会生成XCode及Android Studio工程。通过XCode等工具可以直接运行模拟器或真机。 优雅的方式1、官方推荐的QuickStart，即CRNA：create-react-native-app CRNA方式会生成一个带Expo的环境，但不会有XCode和Android Studio工程。也不会有各种目录配置。通过Expo客户扫描控制台二维码启动应用。 2、Ignite生成项目IGNITE的官方地址：https://github.com/infinitered/ignite IGNITE是一个React Native的脚手架生成器（了解ROR的可以理解为rails命令），通过一个命令就可以生成一个结构完整的、可工作的空白react native项目，后续的开发就是向这个项目添砖加瓦，这比从头构建一个RN项目节省很多时间。而且IGNITE默认集成的很多库也都是不二之选，包含了前人的经验。 ignite new 之后会生成标准的开发结构。包括Reactotron配置等。结构比较重，版本也不见得是最新的！ 3、Expo方式一、概念普及英文读法： [‘ɛkspoʊ]，本身是展览会的意思。 来看官方的解释：https://docs.expo.io/versions/latest/index.html Expo is a set of tools, libraries and services which let you build native iOS and Android apps by writing JavaScript Expo是一组工具、库和服务，可以通过编写JavaScript来构建本地的ios和Android应用程序Expo Apps是包含了Expo SDK的react native Apps,SDK是一个native-and-js的库，它包提供对设备系统的访问功能，像照相机、联系人、本地存储和其他硬件）。这意味着你不需要使用Xcode或Android的环境，或写任何代码也使得你的pure-JS项目非常便携，因为它可以运行在任何自然环境包含Expo SDK。Expo还提供UI组件来处理各种应用程序，几乎所有应用程序都将被覆盖，但它不会突破react native Core的核心代码，例如图标、模糊视图，等等。最后，Expo SDK提供了访问服务，这些服务虽然很难管理，但几乎每个应用程序都需要它。其中最受欢迎的是：Expo可以为您管理您的资产，它可以为您处理推送通知，并且它可以构建准备部署到应用程序商店的本地二进制文件 FaceBook的解释如下： https://facebook.github.io/react-native/docs/more-resources.html Expo is a development environment plus application that focuses on letting you build React Native apps in the Expo development environment, without ever touching Xcode or Android Studio. If you wish React Native was even more JavaScripty and webby, check out Expo. 二、和Ignite等模板的区别？ Ignite是一个脚手架生成工具，提供便捷的模板。区别于Expo，它没有类似环境、服务的概念。某种意义上跟CRNA是一种东西。而后者主要是提供另一种RN开发环境，比如Windows下开发流程等。Ignite可以作为模板扩展，加入到Expo工程里 关于打造自己的脚手架https://zhuanlan.zhihu.com/p/32190298 另外有一篇关于：React Native App应用架构设计绝对是干货：React Native App应用架构设计","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"ReactNative","slug":"RN","permalink":"https://shuoit.net/tags/RN/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Npm安装完后的回调处理","slug":"npm安装完后的回调处理","date":"2018-06-03T11:34:20.000Z","updated":"2018-08-29T12:27:52.361Z","comments":true,"path":"others/npm-script-postinstall/1528025660.html","link":"","permalink":"https://shuoit.net/others/npm-script-postinstall/1528025660.html","excerpt":"","text":"比如在ReactNative中，安装完依赖之后，需要改端口、删掉某些文件…. 多个操作不能在package.json中定义数组，但可以重新定义一个脚本，在脚本中定义操作集合： shell中这么写就行 #!/bin/bashecho 'Now run custom commands after all package is installed.'echo 'modify react-native package-manager default port'react-native-port-patcher --new-port 9090echo 'fix `Font Awesome` could not be found within the package etc.'rm ./node_modules/react-native/local-cli/core/__fixtures__/files/package.json","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://shuoit.net/tags/NodeJS/"}],"keywords":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}]},{"title":"WebStorm语法高亮问题","slug":"WebStorm语法高亮问题","date":"2018-06-03T11:30:04.000Z","updated":"2018-08-29T12:27:52.356Z","comments":true,"path":"others/highlight-webstorm/1528025404.html","link":"","permalink":"https://shuoit.net/others/highlight-webstorm/1528025404.html","excerpt":"","text":"一定程度上解决React-Native开发过程中，WebStorm语法高亮的问题Cannot resolve symbol ‘Component’ &amp; Cannot resolve symbol‘PropTypes’1.解决 Cannot resolve symbol 'Component' 安装依赖：npm install @types/react --save 调用方法：import React, &#123; Component &#125; from 'react'2.解决 Cannot resolve symbol 'PropTypes' 安装依赖：npm install prop-types --save 调用方法：import PropTypes from 'prop-types' https://www.npmjs.com/package/@types/react-native npm install –save @types/react-native","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"WebStrom","slug":"WebStrom","permalink":"https://shuoit.net/tags/WebStrom/"}],"keywords":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}]},{"title":"如果用Redux不爽的话那就试试MobX吧","slug":"如果用Redux不爽的话那就试试MobX吧","date":"2018-06-03T11:22:41.000Z","updated":"2018-08-29T12:27:52.364Z","comments":true,"path":"front-end/mobx-vs-redux/1528024961.html","link":"","permalink":"https://shuoit.net/front-end/mobx-vs-redux/1528024961.html","excerpt":"","text":"Redux之父的建议：unhappy with redux? try mobx…为什么不用Redux了，三个哲学问题（未解之谜）？ Action太多导致不记得Action的命名到底是什么？随便一个需求就要改动多个文件，一个小心写错字符，就够你查半天原因。及时专门写个管理工具，管理起来也非常痛苦； Action的流向到底是什么？ 经种种处理和反复传递，写reducer时，不打个logo真的不知道拿到什么数据结构 中文文档：https://suprise.github.io/mobx-cn/","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"MobX思想的实现原理","slug":"MobX思想的实现原理","date":"2018-06-03T11:13:33.000Z","updated":"2018-08-29T12:27:52.350Z","comments":true,"path":"front-end/mobx-core-study/1528024413.html","link":"","permalink":"https://shuoit.net/front-end/mobx-core-study/1528024413.html","excerpt":"","text":"Mobx 最关键的函数在于 autoRun，举个例子，它可以达到这样的效果：const obj = observable(&#123; a: 1, b: 2&#125;)autoRun(() =&gt; &#123; console.log(obj.a)&#125;)obj.b = 3 // 什么都没有发生obj.a = 2 // observe 函数的回调触发了，控制台输出：2 我们发现这个函数非常智能，用到了什么属性，就会和这个属性挂上钩，从此一旦这个属性发生了改变，就会触发回调，通知你可以拿到新值了。没有用到的属性，无论你怎么修改，它都不会触发回调，这就是神奇的地方。 autoRun 的用途使用 autoRun 实现 mobx-react 非常简单，核心思想是将组件外面包上 autoRun，这样代码中用到的所有属性都会像上面 Demo 一样，与当前组件绑定，一旦任何值发生了修改，就直接 forceUpdate，而且精确命中，效率最高。 依赖收集autoRun 的专业名词叫做依赖收集，也就是通过自然的使用，来收集依赖，当变量改变时，根据收集的依赖来判断是否需要更新。 实现步骤拆解为了兼容，Mobx 使用了 Object.defineProperty 拦截 getter 和 setter，但是无法拦截未定义的变量，为了方便，我们使用 proxy 来讲解，而且可以监听未定义的变量哦。 步骤一 存储结构众所周知，事件监听是需要预先存储的，autoRun 也一样，为了知道当变量修改后，哪些方法应该被触发，我们需要一个存储结构。 首先，我们需要存储所有的代理对象，让我们无论拿到原始对象，还是代理对象，都能快速的找出是否有对应的代理对象存在，这个功能用在判断代理是否存在，是否合法，以及同一个对象不会生成两个代理。 代码如下： const proxies = new WeakMap()function isObservable&lt;T extends object&gt;(obj: T) &#123; return (proxies.get(obj) === obj)&#125; 重点来了，第二个要存储的是最重要的部分，也就是所有监听！当任何对象被改变的时候，我们需要知道它每一个 key 对应着哪些监听（这些监听由 autoRun 注册），也就是，最终会存在多个对象，每个对象的每个 key 都可能与多个 autoRun 绑定，这样在更新某个 key 时，直接触发与其绑定的所有 autoRun 即可。 代码如下： const observers = new WeakMap&lt;object, Map&lt;PropertyKey, Set&gt;&gt;() 第三个存储结构就是待观察队列，为了使同一个调用栈多次赋值仅执行一次 autoRun，所有待执行的都会放在这个队列中，在下一时刻统一执行队列并清空，执行的时候，当前所有 autoRun 都是在同一时刻触发的，所以让相同的 autoRun 不用触发多次即可实现性能优化。 const queuedObservers = new Set() 代码如下： 我们还要再存储两个全局变量，分别是是否在队列执行中，以及当前执行到的 autoRun。 代码如下：let queued = falselet currentObserver: Observer = null 步骤二 将对象加工可观察这一步讲解的是 observable 做了哪些事，首先第一件就是，如果已经存在代理对象了，就直接返回。 代码如下：function observable&lt;T extends object&gt;(obj: T = &#123;&#125; as T): T &#123; return proxies.get(obj) || toObservable(obj)&#125; 我们继续看 toObservable 函数，它做的事情是，实例化代理，并拦截 get set 等方法。 我们先看拦截 get 的作用：先拿到当前要获取的值 result，如果这个值在代理中存在，优先返回代理对象，否则返回 result 本身（没有引用关系的基本类型）。 上面的逻辑只是简单返回取值，并没有注册这一步，我们在 currentObserver 存在时才会给对象当前 key注册 autoRun，并且如果结果是对象，又不存在已有的代理，就调用自身 toObservable 再递归一遍，所以返回的对象一定是代理。 registerObserver 函数的作用是将 targetObj -&gt; key -&gt; autoRun 这个链路关系存到 observers 对象中，当对象修改的时候，可以直接找到对应 key 的 autoRun。 那么 currentObserver 是什么时候赋值的呢？首先，并不是访问到 get 就要注册 registerObserver，必须在 autoRun 里面的才符合要求，所以执行 autoRun 的时候就会将当前回调函数赋值给 currentObserver，保证了在 autoRun 函数内部所有监听对象的 get 拦截器都能访问到 currentObserver。以此类推，其他 autoRun 函数回调函数内部变量 get 拦截器中，currentObserver 也是对应的回调函数。 代码如下：const dynamicObject = new Proxy(obj, &#123; // ... get(target, key, receiver) &#123; const result = Reflect.get(target, key, receiver) // 如果取的值是对象，优先取代理对象 const resultIsObject = typeof result === 'object' &amp;&amp; result const existProxy = resultIsObject &amp;&amp; proxies.get(result) // 将监听添加到这个 key 上 if (currentObserver) &#123; registerObserver(target, key) if (resultIsObject) &#123; return existProxy || toObservable(result) &#125; &#125; return existProxy || result &#125;), // ...&#125;) setter 过程中，如果对象产生了变动，就会触发 queueObservers 函数执行回调函数，这些回调都在 getter 中定义好了，只需要把当前对象，以及修改的 key 传过去，直接触发对应对象，当前 key 所注册的 autoRun 即可。 代码如下：const dynamicObject = new Proxy(obj, &#123; // ... set(target, key, value, receiver) &#123; // 如果改动了 length 属性，或者新值与旧值不同，触发可观察队列任务 if (key === 'length' || value !== Reflect.get(target, key, receiver)) &#123; queueObservers&lt;T&gt;(target, key) &#125; // 如果新值是对象，优先取原始对象 if (typeof value === 'object' &amp;&amp; value) &#123; value = value.$raw || value &#125; return Reflect.set(target, key, value, receiver) &#125;, // ...&#125;) 没错，主要逻辑已经全部说完了，新对象之所以可以检测到，是因为 proxy 的 get 会触发，这要多谢 proxy 的强大。 可能有人问 Object.defineProperty 为什么不行，原因很简单，因为这个函数只能设置某个 key 的 gettersetter~。 symbol proxy reflect 这三剑客能做的事还有很多很多，这仅仅是实现 Object.observe 而已，还有更强大的功能可以挖掘。 mobx 的 proxy 完整实现版本参考 https://github.com/nx-js/observer-util 项目。 谈谈 Redux 与 Mobx 思想的适用场景 Redux 和 Mobx 都是当下比较火热的数据流模型，一个背靠函数式，似乎成为了开源界标配，一个基于面向对象，低调的前行。 函数式 vs 面向对象 首先任何避开业务场景的技术选型都是耍流氓，我先耍一下流氓，首先函数式的优势，比如： 无副作用，可时间回溯，适合并发。 数据流变换处理很拿手，比如 rxjs。 对于复杂数据逻辑、科学计算维的开发和维护效率更高。 当然，连原子都是由带正电的原子核，与带负电的电子组成的，几乎任何事务都没有绝对的好坏，面向对象也存在很多优势，比如： javascript 的鸭子类型，表明它基于对象，不适合完全函数式表达。 数学思维和数据处理适合用函数式，技术是为业务服务的，而业务模型适合用面向对象。 业务开发和做研究不同，逻辑严谨的函数式相当完美，但别指望每个程序员都愿意消耗大量脑细胞解决日常业务问题。 Redux vs Mobx 那么具体到这两种模型，又有一些特定的优缺点呈现出来，先谈谈 Redux 的优势： 数据流流动很自然，因为任何 dispatch 都会导致广播，需要依据对象引用是否变化来控制更新粒度。 如果充分利用时间回溯的特征，可以增强业务的可预测性与错误定位能力。 时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 immutable。 时间回溯的另一个代价是 action 与 reducer 完全脱节，数据流过程需要自行脑补。原因是可回溯必然不能保证引用关系。 引入中间件，其实主要为了解决异步带来的副作用，业务逻辑或多或少参杂着 magic。 但是灵活利用中间件，可以通过约定完成许多复杂的工作。 对 typescript 支持困难。 Mobx： 数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。 没有时间回溯能力，因为数据只有一份引用。 自始至终一份引用，不需要 immutable，也没有复制对象的额外开销。 没有这样的烦恼，数据流动由函数调用一气呵成，便于调试。 业务开发不是脑力活，而是体力活，少一些 magic，多一些效率。 由于没有 magic，所以没有中间件机制，没法通过 magic 加快工作效率（这里 magic 是指 action 分发到 reducer 的过程）。 完美支持 typescript。 到底如何选择从目前经验来看，我建议前端数据流不太复杂的情况，使用 Mobx，因为更加清晰，也便于维护；如果前端数据流极度复杂，建议谨慎使用 Redux，通过中间件减缓巨大业务复杂度，但还是要做到对开发人员尽量透明，如果可以建议使用 typescript 辅助。 https://zhuanlan.zhihu.com/p/25585910 另一组对比： https://zhuanlan.zhihu.com/p/25989654","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Mobx使用详解及最佳实践","slug":"Mobx使用详解及最佳实践","date":"2018-06-03T11:06:22.000Z","updated":"2018-08-29T12:27:52.351Z","comments":true,"path":"front-end/mobx-study/1528023982.html","link":"","permalink":"https://shuoit.net/front-end/mobx-study/1528023982.html","excerpt":"","text":"摘自：作者：Dominic_Ming链接：https://juejin.im/post/5a3b1a88f265da431440dc4a来源：掘金 stores 代表着UI状态永远记住，你的stores代表着你的UI状态，这就意味着，当你将你的stores储存下来后，就算你关了网页，再次打开，载入这个stores，你得到的网页也应该是相同的。虽然stores并不是一个本地数据库的角色，但是他依然存储着一些类似于按钮是否可见，input里面的内容之类的UI状态。 class SearchStore &#123; @observable searchText; @action setSearchText = (searchText) =&gt; &#123; this.searchText = searchText &#125;&#125;@observerclass SearchInput extends React.Component &#123; handleInputChanged = (event) =&gt; &#123; const &#123; searchStore &#125; = this.props; searchStore.setSearchText(event.target.value); &#125; render() &#123; const &#123; searchStore &#125; = this.props; return ( &lt;input value=&#123;searchStore.searchText&#125; onChange=&#123;this.handleInputChanged&#125; /&gt; ); &#125;&#125; 将你的REST API请求和store的action分离不建议将REST API请求的函数放在stores里面，因为这样以来这些请求代码很难测试。你可以尝试把这些请求函数放在一个类里面，把这个类的代码和store放在一起，在store创建时，这个类也相应创建。然后当你测试时，你也可以优雅的把数据从这些类里面mock上去。 class TodoApi &#123; fetchTodos = () =&gt; request.get('/todos')&#125;class TodoStore &#123; @observable todos = []; constructor(todoApi) &#123; this.todoApi = todoApi; &#125; fetchTodos = async () =&gt; &#123; const todos = await this.todoApi.fetchTodos(); runInAction(() =&gt; &#123; this.todos = todos; &#125;); &#125;&#125; // 在你的主要函数里面const todoApi = new TodoApi();const todoStore = new TodoStore(todoApi); 把你的业务逻辑放在stores里面尽量不要把业务逻辑写在你的组件里面。当你把业务逻辑写在组件里面的时候，你是没有办法来及时定位错误的，因为你的业务逻辑分散在各种不同的组件里面，让你很难来通过行为来定义到底是哪些代码涉及的这个错误。最好就把业务逻辑放在stores的方法里面，从组件里面调用。 避免使用全局的store实例请尽量避免使用全局的store实例，因为这样你很难写出有条理而可靠的组件测试。取而代之的是，你可以使用Provider来把你的store inject到你的component实例的props里面。这样你就可以轻松的mock这些store来测试了。 const searchStore = new SearchStore();const app = ( &lt;Provider searchStore=&#123;searchStore&#125;&gt; &lt;SearchInput /&gt; &lt;/Provider&gt;);ReactDom.render(app, container); 只有在store里面才允许改变属性请不要直接在组件里面直接操作store的属性值。因为只有store才能够来修改自己的属性。当你要改变属性的时候，请使用相应的store方法。不然的话你的属性修改会散落在各处不受控制，这是很难debug的。 时刻记得在组件声明 @observer在每个组件声明的时候使用@observer来更新组件的状态。不然在嵌套组件里面，子组件没有声明的话，每次状态更新涉及到的都是父组件级的重新渲染。当你都使用了@observer时，重新渲染的组件数量会大大降低。 使用 @computed就像下面代码的例子，使用@computed属性来处理一些涉及多个属性的逻辑。使用@computed可以减少这样的判断类业务逻辑在组件里面出现的频率。class ApplicationStore &#123; @observable loggedInUser; @observable isInAdminMode; @computed isAdminButtonEnabled = () =&gt; &#123; return this.loggedInUser.role === 'admin' &amp;&amp; this.isInAdminMode; &#125;&#125; 你不需要 react router 来管理状态你不需要使用react router管理状态。就像我前面所说的，你的store就代表了应用的状态。当你让router来管理部份应用状态的时候，这部分状态就从store里面剥离开来。所以尽量使用store来储存所有的UI状态，这样store的属性就是你的界面所得。 倾向于编写可控组件多编写可控组件，这样会大大降低你的测试复杂度，也让你的组件易于管理。","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Redux架构学习","slug":"Redux架构学习","date":"2018-06-03T11:00:59.000Z","updated":"2018-08-29T12:27:52.353Z","comments":true,"path":"front-end/redux-study/1528023659.html","link":"","permalink":"https://shuoit.net/front-end/redux-study/1528023659.html","excerpt":"","text":"整理自：资料：https://segmentfault.com/a/1190000006742449 https://www.zhihu.com/question/41312576/answer/90782136 一、定义Redux is a predictable state container for JavaScript apps.，其中predictable和state container体现了它的作用。那么如何来理解可预测化的呢？这里会有一些函数式编程方面的思想，在Redux中reducer函数是一个纯函数，相同输入一定会是一致的输出，所以确定输入的state那么reducer函数输出的state一定是可以被预测的，因为它只会进行单纯的计算，保证正确的输出。状态容器又是什么？说明Redux有一个专门管理state的地方，就是Store，并且一般情况下是唯一的，应用中所有state形成的一颗状态树就是Store。Redux由Flux演变而来，但受 Elm 的启发，避开了 Flux 的复杂性，我们看看其数据流向： 不同于Flux架构，Redux中没有dispatcher这个概念，并且Redux设想你永远不会变动你的数据，你应该在reducer中返回新的对象来作为应用的新状态。但是它们都可以用(state, action) =&gt; newState来表述其核心思想，所以Redux可以被看成是Flux思想的一种实现，但是在细节上会有一些差异。 二、原则 应用中所有的state都以一个object tree的形式存储在一个单一的store中； 唯一能改变store的方法是触发Action，Action是动作行为的抽象； 为了描述Action如何改变State树，需要编写reducer函数； function testReducer(state, action) &#123; switch (action.type) &#123; case ACTION_TYPE: // calc... return newState; default: return state; &#125; return newState;&#125; state是不可修改的，所以返回的新state应该是基于输入state副本的修改，而不是直接修改state后的返回。可见1、单一数据源，store整个应用的state被存放在一棵Object tree树，并且整个object tree只存在唯一的一个store中。2、State是只读的唯一能改变State的方法是触发Action3、使用纯函数来实现State归并操作，reducer传入待修改的state和一个告知reducer如何修改state的action，reducer将返回action规则对应下操作后的新的state。 reducer(state, action) =&gt; new state 三、数据流严格的单向数据流是Redux设计的核心Redux应用数据的生命周期遵循下面4个步骤： 调用store.dispatch(action), 可以在任何地方进行;Redux store调用传入的reducer函数，并且将当前的state树与action传入。reducer是纯函数，只用于计算下一个state，它应该是完全可被预测的，相同的输入必定会有相同的输出，不能有副作用的操作，如API的调用或者路由跳转，这些应该都是在dispatch前产生；根reducer将多个子reducer输出合并成一个单一的state树；Redux store保存了根reducer返回的完整的state树。新的state树就是应用的下一个状态，现在就可以根据新的state tree来渲染UI React有props和state: props意味着父级分发下来的属性，state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，也就是说数据只能单向向下分发，或者自行内部消化。理解这个是理解React和Redux的前提。 一般构建的React组件内部可能是一个完整的应用，它自己工作良好，你可以通过属性作为API控制它。但是更多的时候发现React根本无法让两个组件互相交流，使用对方的数据。然后这时候不通过DOM沟通（也就是React体制内）解决的唯一办法就是提升state，将state放到共有的父组件中来管理，再作为props分发回子组件。 子组件改变父组件state的办法只能是通过onClick触发父组件声明好的回调，也就是父组件提前声明好函数或方法作为契约描述自己的state将如何变化，再将它同样作为属性交给子组件使用。这样就出现了一个模式：数据总是单向从顶层向下分发的，但是只有子组件回调在概念上可以回到state顶层影响数据。这样state一定程度上是响应式的。 为了面临所有可能的扩展问题，最容易想到的办法就是把所有state集中放到所有组件顶层，然后分发给所有组件。 为了有更好的state管理，就需要一个库来作为更专业的顶层state分发给所有React应用，这就是Redux。让我们回来看看重现上面结构的需求：a. 需要回调通知state (等同于回调参数) -&gt; actionb. 需要根据回调处理 (等同于父级方法) -&gt; reducerc. 需要state (等同于总状态) -&gt; store对Redux来说只有这三个要素：a. action是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑。b. reducer是一个匹配函数，action的发送是全局的：所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻辑处理，修改store中的状态，不相关就不对state做处理原样返回。c. store负责存储状态并可以被react api回调，发布action.当然一般不会直接把两个库拿来用，还有一个binding叫react-redux, 提供一个Provider和connect。很多人其实看懂了redux卡在这里。a. Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以了。它会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。b. connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：mapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。mapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。做好以上流程Redux和React就可以工作了。 简单地说就是：1.顶层分发状态，让React组件被动地渲染。2.监听事件，事件有权利回到所有状态顶层影响状态。","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Flux架构理解","slug":"Flux架构理解","date":"2018-06-03T10:56:52.000Z","updated":"2018-08-29T12:27:52.346Z","comments":true,"path":"front-end/flux-study/1528023412.html","link":"","permalink":"https://shuoit.net/front-end/flux-study/1528023412.html","excerpt":"","text":"1、是个什么鬼？ 如何理解 Facebook 的 flux 应用架构？ Flux 的核心就是一个简单的约定：视图层组件不允许直接修改应用状态，只能触发 action。应用的状态必须独立出来放到 store 里面统一管理，通过侦听 action 来执行具体的状态操作。所谓的单向数据流，就是当用户进行操作的时候，会从组件发出一个 action，这个 action 流到 store 里面，触发 store 对状态进行改动，然后 store 又触发组件基于新的状态重新渲染。即可以看出：视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 “dumb components”（愚蠢组件） 2、结构图","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Git回滚代码笔记","slug":"Git回滚代码笔记","date":"2018-06-03T10:11:07.000Z","updated":"2018-08-29T12:27:52.347Z","comments":true,"path":"others/git-revert/1528020667.html","link":"","permalink":"https://shuoit.net/others/git-revert/1528020667.html","excerpt":"","text":"总有那么一次操作后，想反悔，那么git log先： 此时比如想恢复红框那个版本，执行： git checkout 19d46ca0715df5223d9e30ba9743fc9d95a3bf78 命令结束后，会跳到HEAD分支 复制改项目到另一边，切回之前的分支，把备份覆盖回去。在 git diff 。对比一致后，在提交","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"git","slug":"git","permalink":"https://shuoit.net/tags/git/"}],"keywords":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}]},{"title":"Mac不能更改一个或多个项目因为他们正在使用的解决方法","slug":"Mac不能更改一个或多个项目因为他们正在使用的解决方法","date":"2018-06-03T10:03:12.000Z","updated":"2018-08-29T12:27:52.349Z","comments":true,"path":"others/extended-attri-in-mac/1528020192.html","link":"","permalink":"https://shuoit.net/others/extended-attri-in-mac/1528020192.html","excerpt":"","text":"OS X 系统有的文件移动或复制时，出现“Mac 不能更改一个或多个项目,因为他们正在使用”，这或许是多了个属性导致： 这就解决了，还有，如果是移动设备的文件导致的原因，解决时必须保证移动设备处于可读写状态，对于大部分移动硬盘都是NTFS的问题，可参考如下方法解决： https://coolestguidesontheplanet.com/how-to-write-to-ntfs-external-disk-drives-from-os-x-10-11-el-capitan/ 关于@的解释请参考： http://mackuba.eu/2008/06/30/ls-on-mac-and-extended-file-attributes/","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"Mac必备工具","slug":"MacTools","permalink":"https://shuoit.net/tags/MacTools/"},{"name":"黑科技","slug":"CoolTech","permalink":"https://shuoit.net/tags/CoolTech/"}],"keywords":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}]},{"title":"Dealloc方法不个执行的三种最大可能","slug":"dealloc方法不个执行的三种最大可能","date":"2018-06-03T09:57:27.000Z","updated":"2018-08-29T12:27:52.356Z","comments":true,"path":"front-end/dealloc-not-work/1528019847.html","link":"","permalink":"https://shuoit.net/front-end/dealloc-not-work/1528019847.html","excerpt":"","text":"今天写代码时需要在dealloc里移除所有的通知,但是却发现控制器pop后不执行dealloc方法. 查到这句话:The dealloc method was not being called if any of the references held by a viewcontroller were still in memory. dealloc方法没有被调用是因为控制器的一个或多个强引用仍然在内存中,也就是说当前控制器的计数器不为0.一般的原因有以下几种: 定制器没有被销毁. 解决方法:在viewWillDisappear之前需要把控制器用到的NSTimer销毁. block块使用不当, 因为block会对方法中的变量自动retain一次, 请检查控制器中block代码. 代理必须得用weak修饰, 用strong强引用会导致计数器加1，无法释放内存. 在getter方法里使用self. 导致死循环 Block体内使用实例变量也会造成循环引用，使得拥有这个实例的对象不能释放。","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Swift与OC混编你需要知道的事情2","slug":"Swift与OC混编你需要知道的事情2","date":"2018-06-03T09:39:40.000Z","updated":"2018-08-29T12:27:52.354Z","comments":true,"path":"front-end/swift-oc-coding/1528018780.html","link":"","permalink":"https://shuoit.net/front-end/swift-oc-coding/1528018780.html","excerpt":"","text":"OC中的实例方法与类方法(+和-方法)","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"https://shuoit.net/tags/swift/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Swift与OC混编你需要知道的事情1","slug":"Swift与OC混编你需要知道的事情1","date":"2018-06-03T09:39:37.000Z","updated":"2018-08-29T12:27:52.353Z","comments":true,"path":"front-end/swift-oc-coding/1528018777.html","link":"","permalink":"https://shuoit.net/front-end/swift-oc-coding/1528018777.html","excerpt":"","text":"在Swift中调用OC代码如果是纯OC项目，当你创建第一个Swift文件时，Xcode会提示你建立一个$(PROJECT_NAME)-Bridging-Header.h文件，这个文件就是OC与Swift间相互交流的桥梁文件，即：所有需要在Swift中调用的OC代码，OC头文件必须在这个文件里引入，相反如果是纯Swift项目，当你建立第一个OC语法的文件时，他也会提示，照做就可以了，酱紫就完成了Swift中调用OC。 如果发现建立了桥接文件而项目无法正常编译时，请检查如上配置 在OC中调用Swift代码由于Swift中没有头文件的概念，所有在OC中，直接引入Swift文件，编译器会不高兴的，结果就是编译无法通过！！！所以你需要在调用Swift的OC代码中，引入一个名叫：$(PROJECT_NAME)-Swift.h，这个文件中定义了该项目中所有Swift的类及其方法，不过他是不可见的","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"https://shuoit.net/tags/swift/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Swift命令行入坑","slug":"Swift命令行入坑","date":"2018-06-03T09:05:29.000Z","updated":"2018-08-29T12:27:52.354Z","comments":true,"path":"front-end/swift-in-commandLine/1528016729.html","link":"","permalink":"https://shuoit.net/front-end/swift-in-commandLine/1528016729.html","excerpt":"","text":"当然，Swift也可以编译后运行（二进制文件，直接执行）：","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"https://shuoit.net/tags/swift/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"AES/CBC模式关于加密解密头部缺失的可能性问题","slug":"AES-CBC模式关于加密解密头部缺失的可能性问题","date":"2018-06-03T09:01:10.000Z","updated":"2018-08-29T12:27:52.346Z","comments":true,"path":"front-end/AES_CBC-iOS/1528016470.html","link":"","permalink":"https://shuoit.net/front-end/AES_CBC-iOS/1528016470.html","excerpt":"","text":"如果能解密出来，但是有乱码，如下： 请考虑IV（初始化向量）是不是有误或两个平台下不一样再有，Java端MD5可能直接返回了bytes，并没有最终转成String，注意多平台的区别","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"},{"name":"Java","slug":"Java","permalink":"https://shuoit.net/tags/Java/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"performSelector May Cause a Leak Because Its Selector Is Unknown警告原因及其解决办法","slug":"performSelector-may-cause-a-leak-because-its-selector-is-unknown警告原因及其解决办法","date":"2018-06-03T08:55:44.000Z","updated":"2018-08-29T12:27:52.362Z","comments":true,"path":"front-end/performSelector-warning-fix/1528016144.html","link":"","permalink":"https://shuoit.net/front-end/performSelector-warning-fix/1528016144.html","excerpt":"","text":"问题描述项目中使用到了从字符串创建选择器，编译时发现警告：”performSelector may cause a leak because its selector is unknown”（因为performSelector的选择器未知可能会引起泄漏），为什么在ARC模式下会出现这个警告？ 经过搜索后，在Stackoverflow上发现了一个令人满意的答案。见http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown。 原因在ARC模式下，运行时需要知道如何处理你正在调用的方法的返回值。这个返回值可以是任意值，如void,int,char,NSString,id等等。ARC通过头文件的函数定义来得到这些信息。所以平时我们用到的静态选择器就不会出现这个警告。因为在编译期间，这些信息都已经确定。 如： [someController performSelector:@selector(someMethod)];- (void)someMethod&#123; //bla bla...&#125; 而使用[someController performSelector: NSSelectorFromString(@”someMethod”)];时ARC并不知道该方法的返回值是什么，以及该如何处理？该忽略？还是标记为ns_returns_retained还是ns_returns_autoreleased? 解决办法 1.使用函数指针方式 SEL selector = NSSelectorFromString(@\"someMethod\");IMP imp = [_controller methodForSelector:selector];void (*func)(id, SEL) = (void *)imp;func(_controller, selector); 当有额外参数时，如 SEL selector = NSSelectorFromString(@\"processRegion:ofView:\");IMP imp = [_controller methodForSelector:selector];CGRect (*func)(id, SEL, CGRect, UIView *) = (void *)imp;CGRect result = func(_controller, selector, someRect, someView); 2.使用宏忽略警告 #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [someController performSelector: NSSelectorFromString(@\"someMethod\")]#pragma clang diagnostic pop 通过使用#pragma clang diagnostic push/pop，你可以告诉Clang编译器仅仅为某一特定部分的代码来忽视特定警告。 如果需要忽视的警告有多处，可以定义一个宏 #define SuppressPerformSelectorLeakWarning(Stuff) \\ do &#123; \\ _Pragma(\"clang diagnostic push\") \\ _Pragma(\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\") \\ Stuff; \\ _Pragma(\"clang diagnostic pop\") \\ &#125; while (0) 在产生警告也就是performSelector的地方用使用该宏，如 SuppressPerformSelectorLeakWarning( [_target performSelector:_action withObject:self]); 如果需要performSelector返回值的话， id result;SuppressPerformSelectorLeakWarning( result = [_target performSelector:_action withObject:self]); 3.使用afterDelay [self performSelector:aSelector withObject:nil afterDelay:0.0]; 如果在接受范围内，允许在下一个runloop执行，可以这么做。xCode5没问题，但据反映，xCode6的话这个不能消除警告。","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"旋屏控制及宏定义","slug":"旋屏控制及宏定义","date":"2018-06-03T08:48:09.000Z","updated":"2018-08-29T12:27:52.369Z","comments":true,"path":"front-end/interfaceOrientation-iOS/1528015689.html","link":"","permalink":"https://shuoit.net/front-end/interfaceOrientation-iOS/1528015689.html","excerpt":"","text":"// 横屏设定的宏#define SetScreenOrientation - (BOOL)shouldAutorotate&#123; return YES;&#125;- (NSUInteger)supportedInterfaceOrientations&#123; return UIInterfaceOrientationMaskLandscape;&#125;//单斜杠是除法，双斜杠是注释，反斜杠可以链接宏定义，或连接字符串。 旋屏常用解释 UIInterfaceOrientationMaskLandscape 支持左右横屏UIInterfaceOrientationMaskAll 支持四个方向旋转UIInterfaceOrientationMaskAllButUpsideDown 支持除了UpsideDown以外的旋转 当前屏幕方向interfaceOrientation的获取 有3种方式可以获取到“当前interfaceOrientation”： controller.interfaceOrientation，获取特定controller的方向[[UIApplication sharedApplication] statusBarOrientation] 获取状态条相关的方向[[UIDevice currentDevice] orientation] 获取当前设备的方向","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"三目运算赋值优良的写法","slug":"三目运算赋值优良的写法","date":"2018-06-03T08:45:49.000Z","updated":"2018-08-29T12:27:52.363Z","comments":true,"path":"front-end/three-unary-iOS/1528015549.html","link":"","permalink":"https://shuoit.net/front-end/three-unary-iOS/1528015549.html","excerpt":"","text":"一般写法：float tempOffset = wordsDisplay == DisPlayBottom ? -80 : 80;优质写法：float offset = (DisPlayBottom == wordsDisplay) ? - 80 : 80;遵循常量放左边的原则三目运算也可以这么写：NSString *filetestpaht;filetestpaht = filetestpaht ? : [NSString stringWithFormat:@\"abc\"];","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"iOS布局工具类","slug":"iOS布局工具类","date":"2018-06-03T08:41:56.000Z","updated":"2018-08-29T12:27:52.358Z","comments":true,"path":"front-end/pure-coding-layout-iOS/1528015316.html","link":"","permalink":"https://shuoit.net/front-end/pure-coding-layout-iOS/1528015316.html","excerpt":"","text":"#import &lt;Foundation/Foundation.h&gt;typedef enum&#123; AlignmentCenter = 0, AlignmentTop, AlignmentBottom, AlignmentLeft, AlignmentRight&#125; PlaceAlignmentType;@interface PositionTools : NSObject// 针对默认为竖屏的有效+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container;+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset;+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset;+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset;+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset;+ (void)placeView:(UIView*)subview atTheLeftTopOfTheView:(UIView*)container offset:(CGSize)offset;+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset;+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset;+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset;+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span;+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span;+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span;+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span;+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;// 用来处理横屏的情况下，在屏幕没有旋转到横屏位置之前的情况+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;@end 实现 #import \"PositionTools.h\"@implementation PositionTools+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container&#123; return [self placeView:subview atTheCenterOfTheView:container needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset&#123; return [self placeView:subview atTheLeftMiddleOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset&#123; return [self placeView:subview atTheRightMiddleOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset&#123; return [self placeView:subview atTheTopMiddleOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset&#123; return [self placeView:subview atTheBottomMiddleOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset&#123; return [self placeView:subview atTheRightTopOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset&#123; return [self placeView:subview atTheLeftBottomOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset&#123; return [self placeView:subview atTheRightBottomOfTheView:container offset:offset needAlter:NO];&#125;+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height/2, container.bounds.size.width/2); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width/2, container.bounds.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(offset + subview.frame.size.width/2, container.bounds.size.width/2); &#125; else &#123; subview.center = CGPointMake(offset + subview.frame.size.width/2, container.bounds.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height - (offset + subview.frame.size.width/2), container.bounds.size.width/2); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width - (offset + subview.frame.size.width/2), container.bounds.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height/2, offset + subview.frame.size.height/2); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width/2, offset + subview.frame.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height/2, container.bounds.size.width - (offset + subview.frame.size.height/2)); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width/2, container.bounds.size.height - (offset + subview.frame.size.height/2)); &#125;&#125;+ (void)placeView:(UIView*)subview atTheLeftTopOfTheView:(UIView*)container offset:(CGSize)offset&#123; [container addSubview:subview]; subview.center = CGPointMake(offset.width + subview.frame.size.width/2, offset.height + subview.frame.size.height/2);&#125;+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height - (offset.width + subview.frame.size.width/2), offset.height + subview.frame.size.height/2); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width - (offset.width + subview.frame.size.width/2), offset.height + subview.frame.size.height/2); &#125;&#125;+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(offset.width + subview.frame.size.width/2, container.bounds.size.width - (offset.height + subview.frame.size.height/2)); &#125; else &#123; subview.center = CGPointMake(offset.width + subview.frame.size.width/2, container.bounds.size.height - (offset.height + subview.frame.size.height/2)); &#125;&#125;+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter&#123; [container addSubview:subview]; if (needAlter) &#123; subview.center = CGPointMake(container.bounds.size.height - (offset.width + subview.frame.size.width/2), container.bounds.size.width - (offset.height + subview.frame.size.height/2)); &#125; else &#123; subview.center = CGPointMake(container.bounds.size.width - (offset.width + subview.frame.size.width/2), container.bounds.size.height - (offset.height + subview.frame.size.height/2)); &#125;&#125;+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span&#123; [self placeView:sourceView toTheRightOfTheView:targetView span:span alignmentType:AlignmentCenter];&#125;+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span&#123; [self placeView:sourceView toTheLeftOfTheView:targetView span:span alignmentType:AlignmentCenter];&#125;+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span&#123; [self placeView:sourceView aboveTheView:targetView span:span alignmentType:AlignmentCenter];&#125;+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span&#123; [self placeView:sourceView belowTheView:targetView span:span alignmentType:AlignmentCenter];&#125;+ (void)placeView:(UIView*)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType&#123; [[targetView superview] addSubview:sourceView]; sourceView.center = CGPointMake(targetView.frame.origin.x + targetView.frame.size.width + (span + sourceView.frame.size.width/2), targetView.center.y); [self alignView:sourceView targetView:targetView alignmentType:alignmentType];&#125;+ (void)placeView:(UIView*)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType&#123; [[targetView superview] addSubview:sourceView]; sourceView.center = CGPointMake(targetView.frame.origin.x - (span + sourceView.frame.size.width/2), targetView.center.y); [self alignView:sourceView targetView:targetView alignmentType:alignmentType];&#125;+ (void)placeView:(UIView*)sourceView aboveTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType&#123; [[targetView superview] addSubview:sourceView]; sourceView.center = CGPointMake(targetView.center.x, targetView.frame.origin.y - (span + sourceView.frame.size.height/2)); [self alignView:sourceView targetView:targetView alignmentType:alignmentType];&#125;+ (void)placeView:(UIView*)sourceView belowTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType&#123; [[targetView superview] addSubview:sourceView]; sourceView.center = CGPointMake(targetView.center.x, targetView.frame.origin.y + targetView.frame.size.height + (span + sourceView.frame.size.height/2)); [self alignView:sourceView targetView:targetView alignmentType:alignmentType];&#125;+ (void)alignView:(UIView*)sourceView targetView:(UIView*)targetView alignmentType:(PlaceAlignmentType)alignmentType&#123; if (AlignmentTop == alignmentType) &#123; sourceView.center = CGPointMake(sourceView.center.x, targetView.frame.origin.y + sourceView.frame.size.height/2); &#125; else if (AlignmentBottom == alignmentType) &#123; sourceView.center = CGPointMake(sourceView.center.x, targetView.frame.origin.y + targetView.frame.size.height - sourceView.frame.size.height/2); &#125; else if (AlignmentLeft == alignmentType) &#123; sourceView.center = CGPointMake(targetView.frame.origin.x + sourceView.frame.size.width/2, sourceView.center.y); &#125; else if (AlignmentRight == alignmentType) &#123; sourceView.center = CGPointMake(targetView.frame.origin.x + targetView.frame.size.width - sourceView.frame.size.width/2, sourceView.center.y); &#125;&#125;@end","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"iOS命令行打包","slug":"ios命令行打包","date":"2018-06-03T08:32:32.000Z","updated":"2018-08-29T12:27:52.360Z","comments":true,"path":"front-end/ipa-command-packaging/1528014752.html","link":"","permalink":"https://shuoit.net/front-end/ipa-command-packaging/1528014752.html","excerpt":"","text":"1、概述：打包这事儿其实就是让xcrun来干，而xcodebuild只是xcrun的一个软链接。分工如下： 1、xcodebuild负责讲工程源文件编译成xxx.app；2、xcrun负责给xxx.app签名并打包成xxx.ipa 2、工作步骤：1、先查看本机命令编译环境及需要编译项目的信息： 2、开始编译： 1、清理：xcodebuild -target Test clean2、编译：xcodebuild -target Test3、打包：xcrun -sdk iphoneos PackageApplication -v ./build/Release-iphoneos/Test.app -o ~/ipas/test.ipa 3、查看结果： 4、特别提示： 以上打包方式仅对*.xcodeproj项目有效，如果是cocoapod项目，则需要改一遍编译命令： xcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release -derivedDataPath build","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"iOS属性最佳实践","slug":"iOS属性最佳实践","date":"2018-06-03T08:20:51.000Z","updated":"2018-08-29T12:27:52.357Z","comments":true,"path":"front-end/property-in-action-iOS/1528014051.html","link":"","permalink":"https://shuoit.net/front-end/property-in-action-iOS/1528014051.html","excerpt":"","text":"一、关于objective-C的属性，常见的有：strong、weak、copy、assign 对于基本数据类型，当然使用assigin； 对于mutable的，一定要使用strong。父控件UI元素也使用strong； 子控件元素使用weak； 不可变的类型，使用copy。（NSString,NSArray,NSDictonary这些一定要用copy）对于mutable的对象，如果是mutable的却定义属性为copy，则往里面加值时可能引起程序崩溃。而对于不可变的使用了strong，则可能引起值改变，这就违背了内存管理语义 二、关于getter if (_messageTipNumber &gt; 0) &#123; self.tipCountLable.frame = CGRectMake(150, (self.frame.size.height - 14)/2, 14, 14); self.tipCountLable.layer.cornerRadius = _tipCountLable.frame.size.width/2; self.tipCountLable.text = [NSString stringWithFormat:@\"%d\",_messageTipNumber]; [self.contentView addSubview:_tipCountLable];&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"改变pushViewController的push方向","slug":"改变pushViewController的push方向","date":"2018-06-03T08:18:22.000Z","updated":"2018-08-29T12:27:52.368Z","comments":true,"path":"front-end/pushViewController-change/1528013902.html","link":"","permalink":"https://shuoit.net/front-end/pushViewController-change/1528013902.html","excerpt":"","text":"CATransition* transition = [CATransition animation];transition.type = kCATransitionPush;//可更改为其他方式transition.subtype = kCATransitionFromTop;//可更改为其他方式 [self.navigationController.view.layera ddAnimation:transition forKey:kCATransition];[self.navigationController pushViewController:userLogin animated:NO]; 再来 //可根据上一个页面，来确定当前页以何种方式消失- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self clear]; BOOL fromRight = YES; NSArray *viewControllers = self.navigationController.viewControllers; if ([[viewControllers lastObject] isKindOfClass:[BFEAddContactViewController class]]) &#123; fromRight = NO; &#125; CATransition *transition = [CATransition animation]; transition.type = kCATransitionPush; //页面卸载时，改变PUSH方向 transition.subtype = fromRight ? kCATransitionFromRight : kCATransitionFromLeft; transition.duration = 0.3; transition.delegate = self; [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"iOS随机数获取","slug":"iOS随机数获取","date":"2018-06-03T08:15:19.000Z","updated":"2018-08-29T12:27:52.359Z","comments":true,"path":"front-end/random-objectiveC/1528013719.html","link":"","permalink":"https://shuoit.net/front-end/random-objectiveC/1528013719.html","excerpt":"","text":"ios 有如下三种随机数方法： 1. srand((unsigned)time(0)); //不加这句每次产生的随机数不变 int i = rand() % 5; 2. srandom(time(0)); int i = random() % 5;3. int i = arc4random() % 5 ; 注：rand()和random()实际并不是一个真正的伪随机数发生器，在使用之前需要先初始化随机种子，否则每次生成的随机数一样。 arc4random() 是一个真正的伪随机算法，不需要生成随机种子，因为第一次调用的时候就会自动生成。而且范围是rand()的两倍。在iPhone中，RAND_MAX是0x7fffffff (2147483647)，而arc4random()返回的最大值则是 0x100000000 (4294967296)。 精确度比较：arc4random() &gt; random() &gt; rand()。 常用方法：arc4random 1、获取一个随机整数范围在：[0,100)包括0，不包括100 int x = arc4random() % 100; 2、 获取一个随机数范围在：[500,1000），包括500，不包括1000 int y = (arc4random() % 501) + 500; 3、获取一个随机整数，范围在[from,to），包括from，不包括to -(int)getRandomNumber:(int)from to:(int)to&#123; return (int)(from + (arc4random() % (to – from + 1))); //+1,result is [from to]; else is [from, to)!!!!!!!&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"iOS页面间几种传值方式","slug":"iOS页面间几种传值方式","date":"2018-06-03T08:12:24.000Z","updated":"2018-08-29T12:27:52.359Z","comments":true,"path":"front-end/data-pass-in-iOS/1528013544.html","link":"","permalink":"https://shuoit.net/front-end/data-pass-in-iOS/1528013544.html","excerpt":"","text":"属性：在继承关系下，子类使用父类的数据通过属性最为合适，也最直接明了。 Block：如果有某种继承或所属关系时，父元素要使用子元素的数据，那么此时应该使用block回调。因为此时子元素属性就不一定能取到值（初始化未或动作未必完成）。 消息：两个类根本没有关联，则可以采取发消息的方式。如果两个类可以引入某一方，则还是采取属性或者block方法，因为发消息实际上通过KVO比较消耗系统资源。能不发消息，尽量不要发消息。","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"UIView事件独占","slug":"UIView事件独占","date":"2018-06-03T08:09:46.000Z","updated":"2018-08-29T12:27:52.355Z","comments":true,"path":"front-end/exclusiveTouch-iOS/1528013386.html","link":"","permalink":"https://shuoit.net/front-end/exclusiveTouch-iOS/1528013386.html","excerpt":"","text":"UIView 的exclusiveTouch属性exclusiveTouch的意思是UIView会独占整个Touch事件，具体的来说，就是当设置了exclusiveTouch的 UIView是事件的第一响应者，那么到你的所有手指离开前，其他的视图UIview是不会响应任何触摸事件的，对于多点触摸事件，这个属性就非常重要，值得注意的是：手势识别（GestureRecognizers）会忽略此属性。 列举用途：我们知道ios是没有GridView视图的，通常做法是在UITableView的cell上加载几个子视图，来模拟实现 GridView视图，但对于每一个子视图来说，就需要使用exclusiveTouch，否则当同时点击多个子视图，那么会触发每个子视图的事件。当然 还有我们常说的模态对话框。","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"iOS关于指针定义","slug":"iOS关于指针定义","date":"2018-06-03T08:07:10.000Z","updated":"2018-08-29T12:27:52.357Z","comments":true,"path":"front-end/iOS-Pointer/1528013230.html","link":"","permalink":"https://shuoit.net/front-end/iOS-Pointer/1528013230.html","excerpt":"","text":"关于指针定义（解决 sending ‘const NSString ‘ to parameter of type ‘NSString ‘ ）比如，写了 const NSString* firstString = @\"xxx\";NSString* secondString = @\"yyy\";[secondString isEqualToString:firstString];会出现 sending 'const NSString *' to parameter of type 'NSString *' discards qualifiers 警告。解决办法：把 const NSString* firstString = @\"xxx\";改成 NSString* const firstString = @\"xxx\"; 解释：前者相当于指针本身不可修改，后者表示指针指向的内容不可修改，两者的作用都是使firstString只可读不可写。","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"NSScanner，扫描器","slug":"NSScanner，扫描器","date":"2018-06-03T08:03:29.000Z","updated":"2018-08-29T12:27:52.351Z","comments":true,"path":"front-end/NSScanner/1528013009.html","link":"","permalink":"https://shuoit.net/front-end/NSScanner/1528013009.html","excerpt":"","text":"- (void)testScanNumberFromString&#123; NSString *str = @\"98234hk323hello234你好\"; NSMutableString *numberString = [[NSMutableString alloc] init]; NSScanner *scanner = [NSScanner scannerWithString:str]; NSString *tempString; while (![scanner isAtEnd]) &#123; [scanner scanUpToCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:nil]; //收集数字 [scanner scanCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:&amp;tempString];; [numberString appendString:tempString]; tempString = @\"\"; &#125; NSLog(@\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ number is: %@\",numberString);&#125; 使用 [scanner scanUpToCharactersFromSet:[NSCharacterSet newlineCharacterSet] intoString:&amp;indexString]; //扫描一行[scanner scanUpToString:@\" scanover \" intoString:&amp;theString]; //从游标开始扫描，直到给定字符串为止。期间扫描的字符串存到theString[scanner scanString:@\"sanMe\" intoString:NULL]; //直接扫描指定字符串","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"IOS中URL编码和解码","slug":"IOS中URL编码和解码","date":"2018-06-03T08:01:36.000Z","updated":"2018-08-29T12:27:52.348Z","comments":true,"path":"front-end/url-encoding-iOS/1528012896.html","link":"","permalink":"https://shuoit.net/front-end/url-encoding-iOS/1528012896.html","excerpt":"","text":"int main(int argc, const char * argv[]) &#123; NSString *str = @\"白日依山尽\"; //编码 NSString *encoderStr = [str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //解码 NSString *decoderStr = [encoderStr stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //字符串打散 for (int i = 0; i &lt; str.length; i++) &#123; NSString *word = [str substringWithRange:NSMakeRange(i, 1)]; NSLog(@\"%@\",word); &#125; NSLog(@\"%@\",encoderStr); NSLog(@\"%@\",decoderStr); return 0;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"Id和instancetype的异同","slug":"id和instancetype的异同","date":"2018-06-03T07:58:56.000Z","updated":"2018-08-29T12:27:52.359Z","comments":true,"path":"front-end/instancetype-iOS/1528012736.html","link":"","permalink":"https://shuoit.net/front-end/instancetype-iOS/1528012736.html","excerpt":"","text":"1、相同点 都可以作为方法的返回类型 2、不同点 ①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；②instancetype只能作为返回值，不能像id那样作为参数，比如下面的写法： //err,expected a type - (void)setValue:(instancetype)value &#123; //do something &#125; 就是错的，应该写成： - (void)setValue:(id)value &#123; //do something &#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"MRC和ARC混编","slug":"MRC和ARC混编","date":"2018-06-03T07:54:50.000Z","updated":"2018-08-29T12:27:52.349Z","comments":true,"path":"front-end/mrc-and-arc/1528012490.html","link":"","permalink":"https://shuoit.net/front-end/mrc-and-arc/1528012490.html","excerpt":"","text":"从XCode5以后，默认都采用了ARC，但有时候又想使用MRC，无奈写了MRC语法后，编译器保持： 解决方式如下： 注意：-fno-objc-arc 这句不要有空格。 MRC工程中也可以使用ARC的类。方法如下： 在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"属性变量（Property）与成员变量的区别","slug":"属性变量（property）与成员变量的区别","date":"2018-06-03T07:35:07.000Z","updated":"2018-08-29T12:27:52.367Z","comments":true,"path":"front-end/property-and-memberVar-in-iOS/1528011307.html","link":"","permalink":"https://shuoit.net/front-end/property-and-memberVar-in-iOS/1528011307.html","excerpt":"","text":"@interface MyViewController :UIViewControlle&#123; UIButton *myButton;&#125;@property (nonatomic, retain) UIButton *myButton;@end 类与类别中添加的属性要区分开来，因为类别中只能添加方法，不能添加实例变量。经常会在ios的代码中看到在类别中添加属性，这种情况下，是不会自动生成实例变量的。比如在：UINavigationController.h文件中会对UIViewController类进行扩展 @interface UIViewController (UINavigationControllerItem)@property(nonatomic,readonly,retain) UINavigationItem *navigationItem;@property(nonatomic) BOOL hidesBottomBarWhenPushed;@property(nonatomic,readonly,retain) UINavigationController *navigationController;@end 这里添加的属性，不会自动生成实例变量，这里添加的属性其实是添加的getter与setter方法。 注意一点，匿名类别(匿名扩展)是可以添加实例变量的，非匿名类别是不能添加实例变量的，只能添加方法，或者属性（其实也是方法）。 成员变量用于类内部，无需与外界接触的变量。 根据成员变量的私有性，为了方便访问，所以就有了属性变量。属性变量的好处就是允许让其他对象访问到该变量。当然，你可以设置只读或者可写等，设置方法也可自定义。所以，属性变量是用于与其他对象交互的变量。一些建议: 如果只是单纯的private变量，最好声明在implementation里. 如果是类的public属性，就用property写在.h文件里 如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shuoit.net/tags/iOS/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"将Hexo博客url优化进行到底","slug":"将hexo博客url优化进行到底","date":"2018-06-03T05:19:34.000Z","updated":"2018-08-29T12:27:52.366Z","comments":true,"path":"front-end/permalink-optimize-hexo/1528003174.html","link":"","permalink":"https://shuoit.net/front-end/permalink-optimize-hexo/1528003174.html","excerpt":"","text":"事件源自2017年元旦时的一篇博文在hexo博客中打造相对完美的URL 那篇文章，我向大家介绍了如何在hexo博客中打造一个相对好看、好用的URL链接。然而遗憾的是，时间戳在permalink中没法直接使用。当时说了一个笨办法，就是模板中手动去加时间戳，然后文章生成是再取出来。不知道使用过的朋友有没有喷我… 时隔一年多，我又准备玩hexo了，理由是被类似为知笔记这种东西伤透了心。 然而也是一年多过去了，官方并没有做这样的支持，那我就不高兴了。在强迫症的驱使下，我读了他的源码，发现加这个时间戳相当简单，所以我义不容辞的提了这个PR。这是半个月前发生的事情，在我写这篇文章的时候，官方还没有Merge。所以你如果想在permalink中使用时间戳。办法就是人肉把node_module文件夹下指定的文件做修改。怎么改？改哪个文件？改成啥样？请直接看那个PR。 如果一切顺利，你现在就能愉快的玩耍了。比如： https://shuoit.net/front-end/permalink-optimize-hexo/1528003174.html 当然别忘了配置站点_config.yml permalink: :category/:entitle/:timestamp.html 最后，祝读者们儿童节快乐！","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuoit.net/tags/hexo/"},{"name":"网站","slug":"website","permalink":"https://shuoit.net/tags/website/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]},{"title":"是时候抛弃你的OFFICE全家桶了","slug":"是时候抛弃你的OFFICE全家桶了","date":"2017-09-06T10:00:52.000Z","updated":"2018-08-29T12:27:52.370Z","comments":true,"path":"others/nodeppt/1504692052.html","link":"","permalink":"https://shuoit.net/others/nodeppt/1504692052.html","excerpt":"","text":"今天要说的是一个很炫的东西，叫做NodePPT你是否有这种场景，辛苦做好一份PPT，然后发文件给其他人，奈何人家用的macOS且没有装微软全家桶，如果有Keynote还算好。想表达的意思就是通过这样的Native端办公软件，在跨平台协作上，难免会「丢真」。而今天的主角，将以极客化的方式为你继续PPT之路，让你越来越喜欢装逼…… 项目地址 let’s look look… demo 源码：nodeppt 文档：推荐nodeppt：使用markdown语法来写网页ppt 安装使用啥的，官方文档说的很清楚，以下为我使用笔记1 升级版本： npm update -g nodeppt 2 创建一个文档： // a. 执行如下命令nodeppt create hello// b. 交互式信息补充please input：title (slide title) Hellosubtitle worldspeaker (speaker) Thomas TangSuccess：hello.md, please write your slide content// c. 使用MWeb之类的MD工具开始愉快的编写ppt吧~ 3 启动预览 // 其中，-w表示watch模式，即：改动会时时生效，无需手动刷新浏览器。有没有很*的样子nodeppt start -w -p 9090 将写好的PPT作为gitpages服务发布1 导出全部，包括nodeppt的js、img和css文件夹到执行目录下，如：docs nodeppt generate . docs -a 目前发现两个问题，首先生成docs目录里，还有一个docs目录，在接着执行命令，还会继续生成。直接删掉不需要的目录；其次第一步生成的docs目录用了Git初始化，这就是说如果你的根目录已经用了Git管理，再套一层会导致推送到GitHub对应的目录没有文件，而git status会出现：modified: docs (modified content, untracked content)。解决办法还是删掉.git和.gitignore 2 有了docs目录后，本地打开里面的index.html，看看样式对不对，没问题之后再进行第三步 3 在GitHub Pages的Source处，选择：Use only the /docs folder for GitHub Pages 4 访问配置好的域名，如http://ppt.shuoit.net，就可以远程访问ppt了，这并不需要你在任何平台安装office全家桶 5 剩下的工作就是发挥创造力，码字，做交互。每次写完重复以上步骤就可以使得ppt更新","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://shuoit.net/tags/javascript/"},{"name":"黑科技","slug":"CoolTech","permalink":"https://shuoit.net/tags/CoolTech/"}],"keywords":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}]},{"title":"开始使用Swift语言开发后台","slug":"开始使用Swift语言开发后台","date":"2017-04-22T08:57:44.000Z","updated":"2018-08-29T12:27:52.367Z","comments":true,"path":"back-end/swift-in-serverside/1492851464.html","link":"","permalink":"https://shuoit.net/back-end/swift-in-serverside/1492851464.html","excerpt":"","text":"先分享核心项目和资料Swift in server sidePerfect DocumentationChinese Doc of Perfect Discuss Channel in SlackSlack 后续的事情 之前立了一块牌坊，却始终没有内容，感觉不太合适，后续的笔记，整理整理再发上来….","categories":[{"name":"后台","slug":"back-end","permalink":"https://shuoit.net/categories/back-end/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://shuoit.net/tags/swift/"},{"name":"后台","slug":"serverSide","permalink":"https://shuoit.net/tags/serverSide/"}],"keywords":[{"name":"后台","slug":"back-end","permalink":"https://shuoit.net/categories/back-end/"}]},{"title":"JSimple主题用户指南","slug":"JSimple主题用户指南","date":"2017-04-18T01:49:58.000Z","updated":"2018-08-29T12:27:52.348Z","comments":true,"path":"others/jsimple-usage/1492480198.html","link":"","permalink":"https://shuoit.net/others/jsimple-usage/1492480198.html","excerpt":"","text":"本文将持续跟进主题更新，除了Github的文档，就这里更详细了，有错误发现和建议可以直接提在本文后头 任何的软件作品，不论是成品还是半成品，提供一份易懂的说明还是很重要也非常有必要的。在这件事情上，我很抱歉！因为主题制作过程本来断断续续，开始我也只是想弄个主题供自己用，后来发到Github和hexo官方，发现还是有不少朋友喜欢，在此一并感谢。最近Github反馈的问题很频繁，所以写个文档显得更为迫切和有必要 主题概况大概介绍下，主题的统计用的CNZZ，评论组件用的Disqus，搜索是Google InsightSearch，大致风格是简书网的前身。对于统计和评论，你可以直接改主题的对应文件，替换就好了，只是考虑到统计为私有信息，因此把配置放到了站点配置文件中，如果你为此感到难受，请自己放到主题配置文件里就好。多余的不用纠结。 主题发布这段时间，感谢热心网友提PR改进意见，现在主题已经支持Gitment，代码高亮也显示的比较顺眼了。由于个人原因，博文和主题前半年关注较少，再次一并感谢所有对开源做出贡献的朋友们，谢谢你们。后边，咱们一起装逼，一起飞…. 当你下载了这份主题，改好站点配置后，第一个工作不应该是hexo g或hexo s运行演示，因为这样你一定会遇到错误，要完整的运行，你需要手动配置如下项目： 1、写作模板文件配置在scaffolds文件夹下，保留两个文件即可：post.md和page.md，他们分别表示普通文章和独立页面 post模板内容如下 title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: 唐先森avatar: /images/favicon.pngauthorLink: https://www.tangkunyin.comauthorAbout: https://about.tangkunyin.comauthorDesc: 一个写代码的「伪文人」categories: 技术tags: - 技术- 还是技术keywords: description: photos: - img/2017/demo.jpg--- 如果新建的文章要归属于某个分类，请在categories处对应你的分类名称即可。标签使用同理，一篇文章可以有多个标签，打标签的方式就是写成数组方式。photos是缩略图，地址可以是相对的，也可以是绝对的。 page模板同上，但没有categories和tags，多了comments，后者用来控制独立页是否支持评论组件。至于要把作者的信息放到模板里，是考虑到如果网站采用投稿方式，可以保留原创信息。即：显示不同作者不同文章信息，不会乱！ 2、站点分类别名和自定义URL配置关于自定义URL，请参考这篇文章：在hexo博客中打造相对完美的URL 分类别名和标签别名配置，站点_config.yml文件中，其中主题配置文件里的menu项需要和category_map键值对一致。二者顺序可以不同，但是主题中的顺序决定网站导航栏菜单的顺序。 # Category &amp; Tagdefault_category: 技术category_map: 技术: tech 人文: humanitytag_map: hexo: hexo 生活: life 3、站点左侧导航配置# 便于动态配置导航，最新版把左导航写成配置方式了。注意uri前边的\"-\"，这里是object类型，内层包了数组leftPagesMenu:- uri: pageName // 这个是创建layout为page类型的页面名称，简而言之，就是独立页面名称 title: navName // 故名意思，导航名称，这在大屏幕时体现 faName: fa-wifi // FontAwesome样式名称，最新主题使用了4.7.0，请参考http://fontawesome.io/icons/ 4、社交信息最新一版支持了telegram, instagram, slack, twitter, github, sinaWb, facebook 7中，你要不嫌挤，可以全部配置上 5、关于搜索功能相对于静态博客而言，本站所使用的搜索功能，我个人觉得还是相当赞的，但是这并不意味着需要很复杂的配置，来一起看看你的package.json依赖吧： \"dependencies\": &#123; \"hexo\": \"^3.2.2\", \"hexo-git-backup\": \"^0.1.2\", \"hexo-renderer-ejs\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.11\", \"hexo-renderer-stylus\": \"^0.3.1\", \"hexo-server\": \"^0.2.0\", \"hexo-deployer-git\": \"0.2.0\", \"hexo-generator-archive\": \"^0.1.4\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-generator-json-content\": \"^2.2.0\" &#125; 请注意最后一行，那是用来生成检索数据content.json用的，这个文件在你的public下，当你无法使用搜索时，请务必检查依赖以及是否生成了数据文件。 6、关于CNAME多提一嘴有朋友提Issues说，每次deploy之后，相应的CNAME文件就丢失了，难道每次deploy都需要重新创建CNAME文件，这个怎么解决啊？ 这个只是你把CNAME文件放错位置了而已，解决办法就是把CNAME文件放到主题的source文件夹中，这样就不会丢了","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuoit.net/tags/hexo/"},{"name":"网站","slug":"website","permalink":"https://shuoit.net/tags/website/"}],"keywords":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}]},{"title":"macOS下超赞的工具推荐","slug":"macOS下超赞的工具推荐","date":"2017-01-07T15:51:23.000Z","updated":"2018-08-29T12:27:52.361Z","comments":true,"path":"others/mac-tools/1483804283.html","link":"","permalink":"https://shuoit.net/others/mac-tools/1483804283.html","excerpt":"","text":"以下分享部分为谷歌云端硬盘，所以麻烦自搭梯子Top1飞跃长城请移尊驾 Top2mac系统清理和维护大师，是真大师CleanMyMac Top3抓包王：CharlesCharles Top final终极必杀技，其实很多软件我都是在这里找的，资源直接分享，多写无用，麻烦自提ShareFreeAll","categories":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}],"tags":[{"name":"Mac必备工具","slug":"MacTools","permalink":"https://shuoit.net/tags/MacTools/"}],"keywords":[{"name":"其他","slug":"others","permalink":"https://shuoit.net/categories/others/"}]},{"title":"在hexo博客中打造相对完美的URL","slug":"在hexo博客中打造相对完美的URL","date":"2017-01-07T14:54:05.000Z","updated":"2018-08-29T12:27:52.364Z","comments":true,"path":"front-end/hexo-links/1483800845.html","link":"","permalink":"https://shuoit.net/front-end/hexo-links/1483800845.html","excerpt":"","text":"这里讨论一个处女座的情怀问题如果你是全部用英文写作，那么这篇文章对你确实没什么Luan用。对hexo而言，我们可以很轻松的自定义文章URL。 对数字敏感，你可以在站点的_config.yml文件中permalink处配置成:year/:month/:day/:title/。是的，这个不需要改动，保持hexo默认就是 结果是：http://localhost:4000/2017/04/18/demo 有静态网页情结的你，认为.html结尾利于SEO，则可以把permalink配置成:category/:title.html或:category/:timestamp.html 结果是：http://localhost:4000/demo/1492523268.html 注意第二种使用分类别名，请一定要设置两个地方： // 1、站点的_config.yml中找到以下部分# Category &amp; Tagdefault_category: uncategorizedcategory_map: 演示: demotag_map:// 2、scaffolds/post.md文件中改成如下--- title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125;tags: timestamp: &#123;&#123; date &#125;&#125; categories: 演示--- 是的，增加了两行，在写文章时，通过hexo n demo后，生成的demo.md文件里如下： --- title: hellocategories: 演示date: 2017-04-18 22:19:45timestamp: 1447295415tags:--- 此时需要手动的把timestamp手动改成时间戳，因为这是你自定义的变量，当前hexo还没有这个系统变量使用，所以只能手动配置。 通过以上方式体现的URL更有意义，但是用title或timestamp面临两个问题，前者遇到中文就呵呵了，后者虽精炼但无疑义。所以还有改进的空间，即使用permalink: :category/:title.html这样配置时，创建文章用英文标题。这样解决了中文一坨乱码且意义很明显，读者一看就知道这是哪个分类下的什么文章！ 是不是很美好，赶紧试试去吧~","categories":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shuoit.net/tags/hexo/"},{"name":"网站","slug":"website","permalink":"https://shuoit.net/tags/website/"}],"keywords":[{"name":"前端","slug":"front-end","permalink":"https://shuoit.net/categories/front-end/"}]}]}